/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

namespace Domain.Model {

/** Used for the parsing of metadata. : * 'JSON' : A json document. * 'XML' : An XML document. */
export enum DocumentType {
    Inches = "Inches",
    Centimeter = "Centimeter",
}

/** The customer that joined the service to send/receive packages. */
export class Customer implements ICustomer {
    id?: string;
    name?: string;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

/** The customer that joined the service to send/receive packages. */
export interface ICustomer {
    id?: string;
    name?: string;
}

/** Represents a product for sale. */
export class Product implements IProduct {
    id?: string;
    /** The metadata for this product. */
    metadata?: MetaData;
    /** The categories for this product. */
    category?: Category;
    dateAddedUTC?: string;
    dateDeletedUTC?: string;
    dateUpdatedUTC?: string;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.metadata = _data["metadata"] ? MetaData.fromJS(_data["metadata"]) : <any>undefined;
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.dateAddedUTC = _data["dateAddedUTC"];
            this.dateDeletedUTC = _data["dateDeletedUTC"];
            this.dateUpdatedUTC = _data["dateUpdatedUTC"];
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["dateAddedUTC"] = this.dateAddedUTC;
        data["dateDeletedUTC"] = this.dateDeletedUTC;
        data["dateUpdatedUTC"] = this.dateUpdatedUTC;
        return data; 
    }
}

/** Represents a product for sale. */
export interface IProduct {
    id?: string;
    /** The metadata for this product. */
    metadata?: MetaData;
    /** The categories for this product. */
    category?: Category;
    dateAddedUTC?: string;
    dateDeletedUTC?: string;
    dateUpdatedUTC?: string;
}

/** Data that describes something in the system. */
export class MetaData implements IMetaData {
    id?: string;
    note?: Note;
    document?: string;
    documentType?: DocumentType;
    /** Creates a hierarchy of metadata. */
    subMetadata?: MetaData;

    constructor(data?: IMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
            this.document = _data["document"];
            this.documentType = _data["documentType"];
            this.subMetadata = _data["subMetadata"] ? MetaData.fromJS(_data["subMetadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetaData {
        data = typeof data === 'object' ? data : {};
        let result = new MetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["note"] = this.note ? this.note.toJSON() : <any>undefined;
        data["document"] = this.document;
        data["documentType"] = this.documentType;
        data["subMetadata"] = this.subMetadata ? this.subMetadata.toJSON() : <any>undefined;
        return data; 
    }
}

/** Data that describes something in the system. */
export interface IMetaData {
    id?: string;
    note?: Note;
    document?: string;
    documentType?: DocumentType;
    /** Creates a hierarchy of metadata. */
    subMetadata?: MetaData;
}

/** Used for the categorization of products. */
export class Category implements ICategory {
    id?: string;
    note?: Note;
    /** Creates a hierarchy of categories. */
    subCategory?: Category;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
            this.subCategory = _data["subCategory"] ? Category.fromJS(_data["subCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["note"] = this.note ? this.note.toJSON() : <any>undefined;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        return data; 
    }
}

/** Used for the categorization of products. */
export interface ICategory {
    id?: string;
    note?: Note;
    /** Creates a hierarchy of categories. */
    subCategory?: Category;
}

/** A user, associated with a customer. */
export class User implements IUser {
    /** The id of the user. */
    id?: string;
    customerId?: string;
    /** The name of the user. */
    name?: string;
    /** The token representing the user. */
    token?: string;
    /** The profile attached to this user. */
    profile?: UserProfile;
    /** The claims associated to the user. */
    claims?: UserClaim[];
    /** The groups associated to the user. */
    groups?: UserGroup[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.name = _data["name"];
            this.token = _data["token"];
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(UserGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["name"] = this.name;
        data["token"] = this.token;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data; 
    }
}

/** A user, associated with a customer. */
export interface IUser {
    /** The id of the user. */
    id?: string;
    customerId?: string;
    /** The name of the user. */
    name?: string;
    /** The token representing the user. */
    token?: string;
    /** The profile attached to this user. */
    profile?: UserProfile;
    /** The claims associated to the user. */
    claims?: UserClaim[];
    /** The groups associated to the user. */
    groups?: UserGroup[];
}

/** A group that a user belongs to. */
export class UserGroup implements IUserGroup {
    /** The identity of the user group. */
    id?: string;
    /** The group value. */
    value?: string;

    constructor(data?: IUserGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserGroup {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }
}

/** A group that a user belongs to. */
export interface IUserGroup {
    /** The identity of the user group. */
    id?: string;
    /** The group value. */
    value?: string;
}

/** A claim for a user. */
export class UserClaim implements IUserClaim {
    /** The identification of the user. */
    id?: string;
    /** Subject of the claim. */
    subject?: string;
    /** The type of the claim. */
    type?: string;
    /** The value of the claim. */
    value?: string;
    /** The type of the value. */
    valueType?: string;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data; 
    }
}

/** A claim for a user. */
export interface IUserClaim {
    /** The identification of the user. */
    id?: string;
    /** Subject of the claim. */
    subject?: string;
    /** The type of the claim. */
    type?: string;
    /** The value of the claim. */
    value?: string;
    /** The type of the value. */
    valueType?: string;
}

/** Describes the user, TZ, formatting, location, etc. */
export class UserProfile implements IUserProfile {
    /** The ID for the user profile. */
    id?: string;
    /** The time zone for the user. */
    timeZone?: string;
    /** Used to work out how things need to be formated for display to the user. */
    culture?: string;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timeZone = _data["timeZone"];
            this.culture = _data["culture"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timeZone"] = this.timeZone;
        data["culture"] = this.culture;
        return data; 
    }
}

/** Describes the user, TZ, formatting, location, etc. */
export interface IUserProfile {
    /** The ID for the user profile. */
    id?: string;
    /** The time zone for the user. */
    timeZone?: string;
    /** Used to work out how things need to be formated for display to the user. */
    culture?: string;
}

/** Used to add notes to the entities in the system. */
export class Note implements INote {
    /** The Id of the note. */
    id?: string;
    /** The actual note. */
    value?: string;
    /** The date time the payment outcome was created on, as UTC. */
    createdAtUtc?: Date;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.createdAtUtc = _data["createdAtUtc"] ? new Date(_data["createdAtUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["createdAtUtc"] = this.createdAtUtc ? this.createdAtUtc.toISOString() : <any>undefined;
        return data; 
    }
}

/** Used to add notes to the entities in the system. */
export interface INote {
    /** The Id of the note. */
    id?: string;
    /** The actual note. */
    value?: string;
    /** The date time the payment outcome was created on, as UTC. */
    createdAtUtc?: Date;
}

/** The result of a health check. */
export class HealthCheck implements IHealthCheck {
    /** The sub system that is being tested. */
    subSystem?: string;
    /** If the health check succeeded or failed. */
    successful?: boolean;
    /** All of the errors thrown during the health check. */
    failureReasons?: Note[];

    constructor(data?: IHealthCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subSystem = _data["subSystem"];
            this.successful = _data["successful"];
            if (Array.isArray(_data["failureReasons"])) {
                this.failureReasons = [] as any;
                for (let item of _data["failureReasons"])
                    this.failureReasons!.push(Note.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HealthCheck {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subSystem"] = this.subSystem;
        data["successful"] = this.successful;
        if (Array.isArray(this.failureReasons)) {
            data["failureReasons"] = [];
            for (let item of this.failureReasons)
                data["failureReasons"].push(item.toJSON());
        }
        return data; 
    }
}

/** The result of a health check. */
export interface IHealthCheck {
    /** The sub system that is being tested. */
    subSystem?: string;
    /** If the health check succeeded or failed. */
    successful?: boolean;
    /** All of the errors thrown during the health check. */
    failureReasons?: Note[];
}

/** A key value */
export class Kv implements IKv {
    /** the KEY part of the key value. */
    key?: string;
    /** the VALUE part of the key value. */
    value?: string;

    constructor(data?: IKv) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Kv {
        data = typeof data === 'object' ? data : {};
        let result = new Kv();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

/** A key value */
export interface IKv {
    /** the KEY part of the key value. */
    key?: string;
    /** the VALUE part of the key value. */
    value?: string;
}

/** Used to return the current version of the system. */
export class VersionInformation implements IVersionInformation {
    /** The top number of the version of the software. */
    systemMajorVersion?: number;
    /** The minor number, or sub version of the major version of the software. */
    systemMinorVersion?: number;
    /** The build number of the software. This is a value that will always get larger with each build of the software. */
    buildNumber?: number;
    /** Like the buildNumber, this number always gets larger with each build. */
    revisionNumber?: number;
    /** The UTC date when the software was created. */
    createdOnUtc?: Date;
    /** The current configuration the system is running under. */
    currentConfiguration?: string;
    /** The results of the healthcheck done as part of getting the version information for a system. */
    healthCheck?: HealthCheck[];
    /** The currently injected code. */
    injectedCode?: string[];
    /** The current active feature toggles. */
    featureToggles?: Kv[];
    /** The most recent modifications to the system. */
    recentModifications?: string;

    constructor(data?: IVersionInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemMajorVersion = _data["systemMajorVersion"];
            this.systemMinorVersion = _data["systemMinorVersion"];
            this.buildNumber = _data["buildNumber"];
            this.revisionNumber = _data["revisionNumber"];
            this.createdOnUtc = _data["createdOnUtc"] ? new Date(_data["createdOnUtc"].toString()) : <any>undefined;
            this.currentConfiguration = _data["currentConfiguration"];
            if (Array.isArray(_data["healthCheck"])) {
                this.healthCheck = [] as any;
                for (let item of _data["healthCheck"])
                    this.healthCheck!.push(HealthCheck.fromJS(item));
            }
            if (Array.isArray(_data["injectedCode"])) {
                this.injectedCode = [] as any;
                for (let item of _data["injectedCode"])
                    this.injectedCode!.push(item);
            }
            if (Array.isArray(_data["featureToggles"])) {
                this.featureToggles = [] as any;
                for (let item of _data["featureToggles"])
                    this.featureToggles!.push(Kv.fromJS(item));
            }
            this.recentModifications = _data["recentModifications"];
        }
    }

    static fromJS(data: any): VersionInformation {
        data = typeof data === 'object' ? data : {};
        let result = new VersionInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemMajorVersion"] = this.systemMajorVersion;
        data["systemMinorVersion"] = this.systemMinorVersion;
        data["buildNumber"] = this.buildNumber;
        data["revisionNumber"] = this.revisionNumber;
        data["createdOnUtc"] = this.createdOnUtc ? this.createdOnUtc.toISOString() : <any>undefined;
        data["currentConfiguration"] = this.currentConfiguration;
        if (Array.isArray(this.healthCheck)) {
            data["healthCheck"] = [];
            for (let item of this.healthCheck)
                data["healthCheck"].push(item.toJSON());
        }
        if (Array.isArray(this.injectedCode)) {
            data["injectedCode"] = [];
            for (let item of this.injectedCode)
                data["injectedCode"].push(item);
        }
        if (Array.isArray(this.featureToggles)) {
            data["featureToggles"] = [];
            for (let item of this.featureToggles)
                data["featureToggles"].push(item.toJSON());
        }
        data["recentModifications"] = this.recentModifications;
        return data; 
    }
}

/** Used to return the current version of the system. */
export interface IVersionInformation {
    /** The top number of the version of the software. */
    systemMajorVersion?: number;
    /** The minor number, or sub version of the major version of the software. */
    systemMinorVersion?: number;
    /** The build number of the software. This is a value that will always get larger with each build of the software. */
    buildNumber?: number;
    /** Like the buildNumber, this number always gets larger with each build. */
    revisionNumber?: number;
    /** The UTC date when the software was created. */
    createdOnUtc?: Date;
    /** The current configuration the system is running under. */
    currentConfiguration?: string;
    /** The results of the healthcheck done as part of getting the version information for a system. */
    healthCheck?: HealthCheck[];
    /** The currently injected code. */
    injectedCode?: string[];
    /** The current active feature toggles. */
    featureToggles?: Kv[];
    /** The most recent modifications to the system. */
    recentModifications?: string;
}

}